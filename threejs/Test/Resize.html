<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Test</title>
    <style>
        body {
            overflow: hidden;
            margin: 0px;
        }

        .mainContent {
            text-align: center;
        }
    </style>
</head>

<body>

    <script type="importmap">
        {
            "imports": {
                "three": "../three.js-master/build/three.module.js",
                "three/addons/": "../three.js-master/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { OutlinePass } from 'three/addons/postprocessing/OutlinePass.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';


        //场景
        const scene = new THREE.Scene();


        //辅助观察的坐标系
        const axesHelper = new THREE.AxesHelper(100);
        scene.add(axesHelper);


        //光源设置
        const directionalLight = new THREE.DirectionalLight(0xffffff, 5);
        directionalLight.position.set(100, 100, 100);
        scene.add(directionalLight);
        const ambient = new THREE.AmbientLight(0xffffff, 1);
        scene.add(ambient);


        //渲染器和相机
        const width = window.innerWidth;
        const height = window.innerHeight;
        const camera = new THREE.PerspectiveCamera(60, width / height, 1, 1000);
        // camera.position.set(3, 3, 3);
        // camera.lookAt(0, 0, 0);

        // WebGL渲染器设置
        const renderer = new THREE.WebGLRenderer({
            antialias: true,//开启优化锯齿
        });
        renderer.setPixelRatio(window.devicePixelRatio);//防止输出模糊
        renderer.setSize(width, height);
        document.body.appendChild(renderer.domElement);

        //canvas画布背景颜色
        //第二个参数是alpha通道（不透明）
        renderer.setClearColor(0xFAD7A0, 1);
        document.body.appendChild(renderer.domElement);


        // 加载 GLTF 模型  
        const loader = new GLTFLoader();
        loader.load('./合1.glb', function (gltf) {
            const model = gltf.scene;
            scene.add(model);

            // 计算边界框并调整模型和相机
            adjustModelAndCamera(model, camera);

            // 渲染场景
            renderer.render(scene, camera);
        });

        function adjustModelAndCamera(model, camera) {
            const bbox = new THREE.Box3().setFromObject(model);
            const center = bbox.getCenter(new THREE.Vector3());
            const size = bbox.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const desiredSize = 2; // 相对于视口的大小比例（可以调整）
            const scale = desiredSize / maxDim;
            model.scale.set(scale, scale, scale);

            // 调整相机距离以适应模型
            const fov = camera.fov * (Math.PI / 180);
            camera.position.x= Math.abs(maxDim * scale) / 2 / Math.tan(fov / 2);
            camera.position.y= Math.abs(maxDim * scale) / 2 / Math.tan(fov / 2);
            camera.position.z= Math.abs(maxDim * scale) / 2 / Math.tan(fov / 2);
          
            

            // 更新相机投影矩阵
            camera.updateProjectionMatrix();
            camera.lookAt(center);
            renderer.render(scene, camera);
        };

        // 窗口大小变化时更新渲染器和相机
        window.addEventListener('resize', function () {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.render(scene, camera);
        });

        // 渲染循环
        function render() {
            renderer.render(scene, camera);
            requestAnimationFrame(render);
        }
        render();


        const controls = new OrbitControls(camera, renderer.domElement);

        // 画布跟随窗口变化
        window.onresize = function () {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.render(scene, camera);
        };

    </script>
</body>

</html>
